{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/eventrecorder/source/class/cboulanger/eventrecorder/player/Abstract.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "include",
    "cboulanger",
    "eventrecorder",
    "MState",
    "MHelperMethods",
    "statics",
    "utilityFunctions",
    "waitForCondition",
    "fn",
    "interval",
    "timeout",
    "timeoutMsg",
    "Promise",
    "resolve",
    "reject",
    "intervalId",
    "setInterval",
    "clearInterval",
    "setTimeout",
    "Error",
    "waitForEvent",
    "qxObjOrId",
    "type",
    "expectedData",
    "qxObj",
    "lang",
    "Type",
    "isString",
    "Id",
    "getQxObject",
    "getTimeout",
    "timeoutId",
    "removeListener",
    "changeEventHandler",
    "e",
    "app",
    "Init",
    "getApplication",
    "eventdata",
    "event",
    "Data",
    "getData",
    "undefined",
    "warn",
    "addListenerOnce",
    "isArray",
    "length",
    "index",
    "expectedItem",
    "entries",
    "JSON",
    "stringify",
    "isRegExp",
    "match",
    "toString",
    "info",
    "clearTimeout",
    "properties",
    "mode",
    "check",
    "init",
    "apply",
    "useDefaultDelay",
    "nullable",
    "maxDelay",
    "canReplayInBrowser",
    "canExportExecutableCode",
    "macros",
    "events",
    "construct",
    "__commands",
    "_globalRef",
    "window",
    "resetMacros",
    "name",
    "members",
    "__macro_stack",
    "__macro_stack_index",
    "__macro_playing",
    "__import_playing",
    "__vars",
    "__promises",
    "__lastId",
    "__lastCmd",
    "getType",
    "getLastId",
    "getLastCommand",
    "_applyMode",
    "value",
    "old",
    "_addCommands",
    "commands",
    "concat",
    "sort",
    "a",
    "b",
    "getCommands",
    "getMacros",
    "dispose",
    "data",
    "marshal",
    "Json",
    "createModel",
    "names",
    "definitions",
    "descriptions",
    "setMacros",
    "macroExists",
    "getNames",
    "indexOf",
    "getMacroNames",
    "getMacroDefinition",
    "getDefinitions",
    "getItem",
    "getMacroDescription",
    "getDescriptions",
    "addMacro",
    "description",
    "push",
    "beginMacroDefintion",
    "isInMacroDefinition",
    "getCurrentMacroName",
    "leaveMacroDefinition",
    "_translateLine",
    "line",
    "trim",
    "startsWith",
    "addComment",
    "substr",
    "command",
    "args",
    "tokenize",
    "String",
    "toLocaleLowerCase",
    "method_name",
    "replace",
    "translatedLine",
    "then",
    "Array",
    "isInAwaitBlock",
    "_addPromiseToAwaitStack",
    "_handleMeta",
    "script",
    "expandVariables",
    "lines",
    "split",
    "var_def",
    "_getMacro",
    "macro_name",
    "macro_lines",
    "i",
    "map",
    "l",
    "RegExp",
    "_defineVariables",
    "getOwnPropertyNames",
    "key",
    "_translateVariables",
    "var_name",
    "var_content",
    "_generateUtilityFunctionsCode",
    "filter",
    "Boolean",
    "join",
    "_play",
    "steps",
    "step",
    "getRunning",
    "debug",
    "fireDataEvent",
    "getMode",
    "result",
    "code",
    "repeat",
    "eval",
    "macro",
    "import",
    "scriptcode",
    "scriptline",
    "replay",
    "scriptOrLines",
    "setRunning",
    "await_block",
    "msg",
    "message",
    "error",
    "qxl",
    "dialog",
    "Dialog",
    "Timer",
    "once",
    "cmd_hide_info",
    "translate",
    "_translate",
    "includeUtilityFunctions",
    "translatedLines",
    "new_lines",
    "translation",
    "generateWaitForConditionCode",
    "condition",
    "timeoutmsg",
    "Assert",
    "assertString",
    "getInterval",
    "generateWaitForEventCode",
    "id",
    "generateWaitForEventTimoutFunction",
    "comment",
    "escapeRegexpChars",
    "s",
    "createRegexpForJsonComparison",
    "searchExp",
    "foundRegExps",
    "m",
    "slice",
    "promiseCode",
    "getExportFileExtension",
    "_getStorage",
    "bom",
    "storage",
    "Web",
    "getSession",
    "_saveImport",
    "uri",
    "setItem",
    "_getImport",
    "_clearImports",
    "forEach",
    "removeItem",
    "cmd_import",
    "remoteScript",
    "getRawGist",
    "cmd_clear_imports",
    "cmd_assert_uri",
    "cmd_assert_match_uri",
    "uri_regexp",
    "cmd_config_set_mode",
    "cmd_define",
    "macro_description",
    "cmd_end",
    "cmd_await_all",
    "cmd_error",
    "player",
    "Abstract"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n  UI Event Recorder\n\n  Copyright:\n    2018 Christian Boulanger\n\n  License:\n    MIT license\n    See the LICENSE file in the project's top-level directory for details.\n\n  Authors: Christian Boulanger\n\n************************************************************************ */\n\n/**\n * The base class of all player types\n * @require(qx.bom.Element)\n */\nqx.Class.define(\"cboulanger.eventrecorder.player.Abstract\", {\n  extend : qx.core.Object,\n  include : [\n    cboulanger.eventrecorder.MState,\n    cboulanger.eventrecorder.MHelperMethods\n  ],\n\n  statics: {\n    utilityFunctions : {\n      /**\n       * Runs the given function in the interval until it returns true or the\n       * given timeout is reached. Returns a promise that will resolve once the\n       * function returns true or rejects if the timeout is reached.\n       * @param fn {Function} Condition function\n       * @param interval {Number} The interval in which to run the function. Defaults to 100 ms.\n       * @param timeout {Number} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForCondition: function(fn, interval=100, timeout=10000, timeoutMsg) {\n        return new Promise(((resolve, reject) => {\n          let intervalId = setInterval(() => {\n            if (fn()) {\n              clearInterval(intervalId);\n              resolve();\n            }\n          }, interval);\n          setTimeout(() => {\n            clearInterval(intervalId);\n            reject(new Error(timeoutMsg || `Timeout waiting for condition.`));\n          }, timeout);\n        }));\n      },\n\n      /**\n       * Returns a promise that will resolve (with any potential event data) if\n       * the given object fires an event with the given type and will reject if\n       * the timeout is reached before that happens.\n       *\n       * @param qxObjOrId {qx.core.Object|String} If string, assume it is the object id\n       * @param type {String} Type of the event\n       * @param expectedData {*|undefined} The data to expect. If undefined,\n       * resolve. If a regular expression, the event data as a JSON literal will\n       * be matched with that regex and the promise will resolve when it matches.\n       * Otherwise, the data will be compared with the actual event data both\n       * serialized to JSON.\n       * @param timeout {Number|undefined} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForEvent: function(qxObjOrId, type, expectedData, timeout, timeoutMsg) {\n        let qxObj = qxObjOrId;\n        if (qx.lang.Type.isString(qxObjOrId)) {\n          qxObj = qx.core.Id.getQxObject(qxObjOrId);\n          if (!qxObj) {\n            throw new Error(`Invalid object id ${qxObjOrId}`);\n          }\n        }\n        timeout = timeout || this.getTimeout();\n\n        return new Promise(((resolve, reject) => {\n          // create a timeout\n          let timeoutId = setTimeout(() => {\n            qxObj.removeListener(type, changeEventHandler);\n            reject(new Error(timeoutMsg || `Timeout waiting for event \"${type}.`));\n          }, timeout);\n\n          // function to create a listener for the change event\n          let changeEventHandler = e => {\n            let app = qx.core.Init.getApplication();\n            let eventdata = e instanceof qx.event.type.Data ? e.getData() : undefined;\n            if (expectedData !== undefined) {\n              if (eventdata === undefined) {\n                app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received 'undefined'`);\n                qxObj.addListenerOnce(type, changeEventHandler);\n                return;\n              }\n              if (qx.lang.Type.isArray(expectedData) && qx.lang.Type.isArray(eventdata) && expectedData.length && expectedData[0] instanceof qx.core.Object) {\n                /** a) either match array and check for \"live\" qooxdoo objects in the array (this is for selections), */\n                for (let [index, expectedItem] of expectedData.entries()) {\n                  if (expectedItem !== eventdata[index]) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received non-matching array of qooxdoo objects!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              } else {\n                // convert event data to JSON\n                try {\n                  eventdata = JSON.stringify(e.getData());\n                } catch (e) {\n                  throw new Error(`\\n--- When waiting for event '${type}' on object ${qxObj}, could not stringify event data for comparison.`);\n                }\n                if (qx.lang.Type.isRegExp(expectedData)) {\n                  /** b) or match a regular expression, */\n                  if (!eventdata.match(expectedData)) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected data to match '${expectedData.toString()}', got ${eventdata}!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                } else {\n                  /* c) or compare JSON equality */\n                  try {\n                    expectedData = JSON.stringify(expectedData);\n                  } catch (e) {\n                    throw new Error(`When waiting for event '${type}' on object ${qxObj}, could not stringify expected data for comparison.`);\n                  }\n                  if (eventdata !== expectedData) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected '${JSON.stringify(expectedData)}', got '${JSON.stringify(eventdata)}'!\"`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              }\n            }\n            app.info(`\\n+++ Received correct event '${type}' on object ${qxObj}.\"`);\n            clearTimeout(timeoutId);\n            resolve(eventdata);\n          };\n\n          // add a listener\n          qxObj.addListenerOnce(type, changeEventHandler);\n        }));\n      }\n    }\n  },\n\n  properties: {\n    /**\n     * The replay mode. Possible values:\n     * \"test\": The script is executed ignoring the \"delay\" commands, errors will\n     * stop execution and will be thrown.\n     * \"presentation\": The script is executed with user delays, errors will be\n     * logged to the console but will not stop execution\n     */\n    mode: {\n      check: [\"test\", \"presentation\"],\n      event: \"changeMode\",\n      init: \"presentation\",\n      apply: \"_applyMode\"\n    },\n\n    /**\n     * The timeout in milliseconds\n     */\n    timeout: {\n      check: \"Number\",\n      init: 10000\n    },\n\n    /**\n     * The interval between checks if waiting for a condition to fulfil\n     */\n    interval: {\n      check: \"Number\",\n      init: 100\n    },\n\n    /**\n     * if true, ignore user delays and use defaultDelay\n     */\n    useDefaultDelay: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false\n    },\n\n    /**\n     * The maximun delay between events (limits user-generated delay)\n     */\n    maxDelay: {\n      check: \"Number\",\n      init: 1000\n    },\n\n    /**\n     * Whether the player can replay the generated script in the browser\n     */\n    canReplayInBrowser: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanReplay\"\n    },\n\n    /**\n     * Whether the player can export code that can be used outside this application\n     */\n    canExportExecutableCode: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanExportExecutableCode\"\n    },\n\n    /**\n     * Macro data\n     */\n    macros: {\n      check: \"qx.core.Object\",\n      init: null,\n      event: \"changeMacros\"\n    }\n  },\n\n  events: {\n    /**\n     * Fired with each step of the replayed script. The event data is an array\n     * containing the number of the step and the number of steps\n     */\n    \"progress\" : \"qx.event.type.Data\"\n  },\n\n  /**\n   * constructor\n   */\n  construct: function() {\n    this.base(arguments);\n    this.__commands = [];\n    this._globalRef = \"eventrecorder_player\";\n    window[this._globalRef] = this;\n    this.resetMacros();\n    // inject utility functions in the statics section into the global scope\n    // so that they are available in eval()\n    for (let [name, fn] of Object.entries(this.self(arguments).utilityFunctions)) {\n      window[name] = fn;\n    }\n  },\n\n  /**\n   * The methods and simple properties of this class\n   */\n  members :\n  {\n    /**\n     * A globally accessible reference to the player implementation\n     */\n    _globalRef: null,\n\n    /**\n     * A list of available commands\n     */\n    __commands: null,\n\n    /**\n     * An array of object containing information on the macros that are currently\n     * being defined (in a nested way)\n     * @var {Object[]}\n     */\n    __macro_stack: null,\n\n    /**\n     * The index of the macro in the macro stack that is currently defined\n     * @var {Integer}\n     */\n    __macro_stack_index: -1,\n\n    /**\n     * Contains the name of the macro that is currently being replayed, if any.\n     */\n    __macro_playing: null,\n\n    /**\n     * Whether the currently replayed code is an import\n     */\n    __import_playing: false,\n\n    /**\n     * Variables\n     */\n    __vars: null,\n\n    /**\n     * An array of promises which are to be awaited\n     */\n    __promises: null,\n\n    /**\n     * Last id addressed\n     */\n    __lastId : null,\n\n    /**\n     * Last command used\n     */\n    __lastCmd : null,\n\n    /**\n     * Returns the player type\n     * @return {String}\n     */\n    getType() {\n      throw new Error(\"Abstract method which needs to be implemented\");\n    },\n\n    /**\n     * Return the last id used\n     * @return {String|null}\n     */\n    getLastId() {\n      return this.__lastId;\n    },\n\n    /**\n     * Return the last command used\n     * @return {String|null}\n     */\n    getLastCommand() {\n      return this.__lastCmd;\n    },\n\n    /**\n     * Stub to be overridden if needed\n     * @param value\n     * @param old\n     * @private\n     */\n    _applyMode(value, old) {},\n\n    /**\n     * NOT IMPLEMENTED\n     * Adds the given array of commands\n     * @param commands {Object[]}\n     */\n    _addCommands(commands) {\n      this.__commands = this.__commands.concat(commands).sort((a, b) => a.name > b.name);\n    },\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the list of availabe commands\n     * @return {Object[]}\n     */\n    getCommands() {\n      return this.__commands;\n    },\n\n    /**\n     * Clears all macro definitions and the macro stack\n     */\n    resetMacros() {\n      if (this.getMacros()) {\n        this.getMacros().dispose();\n      }\n      this.__macro_stack = [];\n      this.__macro_stack_index = -1;\n      let macros = qx.data.marshal.Json.createModel({\n        names: [],\n        definitions: [],\n        descriptions: []\n      }, true);\n      this.setMacros(macros);\n    },\n\n    /**\n     * Returns true if a macro of that name exists.\n     * @param name {String}\n     * @return {boolean}\n     */\n    macroExists(name) {\n      return this.getMacros().getNames().indexOf(name) >= 0;\n    },\n\n    /**\n     * Returns the names of the currently defined macros as a qx.data.Array\n     * @return {qx.data.Array}\n     */\n    getMacroNames() {\n      return this.getMacros().getNames();\n    },\n\n    /**\n     * Returns an array with the lines of the macro of that name\n     * @param name {String}\n     * @return {Array}\n     */\n    getMacroDefinition(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDefinitions().getItem(index);\n    },\n\n    /**\n     * Returns the description of the macro\n     * @param name {String}\n     * @return {String}\n     */\n    getMacroDescription(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDescriptions().getItem(index);\n    },\n\n    /**\n     * Adds an empty macro of this name\n     * @param name {String}\n     * @param description {String|undefined}\n     */\n    addMacro(name, description) {\n      if (this.macroExists(name)) {\n        throw new Error(`A macro of the name '${name}' alread exists.`);\n      }\n      let macros = this.getMacros();\n      macros.getDefinitions().push([]);\n      macros.getDescriptions().push(description||\"\");\n      macros.getNames().push(name);\n    },\n\n    /**\n     * Begins the definition of a macro of that name.\n     * @param name {String}\n     */\n    beginMacroDefintion(name) {\n      let index = ++this.__macro_stack_index;\n      this.__macro_stack[index] = { name };\n    },\n\n    /**\n     * Returns true if the player is currently in a macro definition\n     * @return {boolean}\n     */\n    isInMacroDefinition() {\n      return this.__macro_stack_index >= 0;\n    },\n\n    /**\n     * Return the name of the macro that is currently being defined\n     * @return {String}\n     */\n    getCurrentMacroName() {\n      if (!this.isInMacroDefinition()) {\n        throw new Error(\"No macro is currently defined\");\n      }\n      let {name} = this.__macro_stack[this.__macro_stack_index];\n      return name;\n    },\n\n    /**\n     * Leave the current macro, i.e. return to the including script/macro\n     */\n    leaveMacroDefinition() {\n      this.getCurrentMacroName(); // this will throw if none is being defined\n      this.__macro_stack_index--;\n    },\n\n    /**\n     * Translates a single line from the intermediate code into the target\n     * language. To be overridden by subclasses if neccessary. Returns a\n     * single line in most cases, an array of lines in case of imports.\n     *\n     * @param line {String}\n     * @return {String|String[]}\n     * @ignore(command)\n     * @ignore(args)\n     */\n    async _translateLine(line) {\n      line = line.trim();\n      if (!line) {\n        return null;\n      }\n      // comment\n      if (line.startsWith(\"#\")) {\n        return this.addComment(line.substr(1).trim());\n      }\n      // parse command line\n\n      let [command, ...args] = this.tokenize(line);\n      command = String(command).toLocaleLowerCase();\n      this.__lastCmd = command;\n      this.__lastId = args[0]; // assume first argument is id\n      // run command generation implementation\n      let method_name = \"cmd_\" + command.replace(/-/g, \"_\");\n      if (typeof this[method_name] == \"function\") {\n        let translatedLine = this[method_name].apply(this, args);\n        // async translator function\n        if (translatedLine && typeof translatedLine.then == \"function\") {\n          translatedLine = await translatedLine;\n        }\n        // imports\n        if (Array.isArray(translatedLine)) {\n          return translatedLine;\n        }\n        if (translatedLine && translatedLine.startsWith(\"(\") && this.isInAwaitBlock()) {\n          this._addPromiseToAwaitStack(translatedLine);\n          return null;\n        }\n        return translatedLine;\n      }\n      throw new Error(`Unsupported/unrecognized command: '${command}'`);\n    },\n\n    /**\n     * Given a script, return an array of lines with all variable and macro\n     * declarations registered and removed. Optionally, variables are expanded.\n     *\n     * @param script {String}\n     * @param expandVariables {Boolean} Whether to expand the found variables. Default to true\n     * @return {Array}\n     * @private\n     */\n    async _handleMeta(script, expandVariables=true) {\n      this.resetMacros();\n      this.__vars = {};\n      let lines = [];\n      for (let line of script.split(/\\n/)) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        // expand variables\n        let var_def = line.match(/([^=\\s]+)\\s*=\\s*(.+)/);\n        if (var_def) {\n          this.__vars[var_def[1]] = var_def[2];\n          continue;\n        } else if (expandVariables && line.match(/\\$([^\\s\\d\\/]+)/)) {\n          line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => this.__vars[args[1]]);\n        }\n\n        // register macros\n        if (line.startsWith(\"define \")) {\n          if (this.isInAwaitBlock()) {\n            throw new Error(\"You cannot use a macro in an await block.\");\n          }\n          await this._translateLine(line);\n          continue;\n        }\n\n        // await block\n        if (line.startsWith(\"await-\")) {\n          await this._translateLine(line);\n        }\n\n        // end await block or macro\n        if (line === \"end\") {\n          // macro\n          if (!this.isInAwaitBlock()) {\n            await this._translateLine(line);\n            continue;\n          }\n          // await block\n          await this._translateLine(line);\n        }\n\n        // add code to macro\n        if (this.isInMacroDefinition()) {\n          let name = this.getCurrentMacroName();\n          this.getMacroDefinition(name).push(line);\n          continue;\n        }\n        lines.push(line);\n      }\n      // remove variable registration if they have been expanded\n      if (expandVariables) {\n        this.__vars = {};\n      }\n      return lines;\n    },\n\n    /**\n     * Returns the lines for the macro of the given name, with the given arguments\n     * replaced (1st arg -> $1, 2nd arg -> $2, etc.). If it doesn't exist,\n     * return undefined.\n     * @param macro_name {String} The name of the macro\n     * @param args {Array} An array of arguments to be replaced in the macro code\n     * @return {Array|undefined}\n     * @private\n     */\n    _getMacro(macro_name, args) {\n      if (!this.macroExists(macro_name)) {\n        return undefined;\n      }\n      let macro_lines = this.getMacroDefinition(macro_name);\n      // argument placeholders\n      for (let i = 0; i < args.length; i++) {\n        macro_lines = macro_lines.map(l => l.replace(new RegExp(\"\\\\$\" + (i + 1), \"g\"), JSON.stringify(args[i])));\n      }\n      return macro_lines;\n    },\n\n\n    /**\n     * Returns an array of lines containing variable declarations\n     * @return {string[]}\n     * @private\n     */\n    _defineVariables() {\n      return Object.getOwnPropertyNames(this.__vars)\n        .map(key => `const ${key} =\"${this.__vars[key]}\";`);\n    },\n\n    /**\n     * Translates variables in a line\n     * @param line {String}\n     * @private\n     * @return {String}\n     * @ignore(args)\n     */\n    _translateVariables(line) {\n      if (line.match(/\\$([^\\s\\d\\/]+)/)) {\n        line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => {\n          let var_name = args[1];\n          let var_content = this.__vars[var_name];\n          if (var_content === undefined) {\n            throw new Error(`Variable '${var_name}' has not been defined.`);\n          }\n          return var_content;\n        });\n      }\n      return line;\n    },\n\n    /**\n     * Returns the code of utility functions needed for the command implementations.\n     * @param script {String} Optional script code to be searched for the function name.\n     * If given, omit function if not present in the script code\n     * @return {string[]}\n     * @private\n     * @ignore(fn)\n     */\n    _generateUtilityFunctionsCode(script) {\n      return Object.entries(this.self(arguments).utilityFunctions)\n        .filter(([name]) => script ? script.match(new RegExp(name)) : true)\n        .map(([name, fn]) => fn.toString()\n          .replace(/function \\(/, `function ${name}(`)\n          // remove comments, see https://stackoverflow.com/questions/5989315/regex-for-match-replacing-javascript-comments-both-multiline-and-inline\n          .replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, \"$1\")\n          .split(/\\n/)\n          .map(line => line.trim())\n          .filter(line => Boolean(line))\n          .join(\"\")\n        );\n    },\n\n    /**\n     * Replays a number of script lines\n     * @param lines {String[]}\n     * @param steps {Integer?}\n     * @param step {Integer?}\n     * @return {Promise<boolean>}\n     * @private\n     */\n    async _play(lines, steps=0, step=0) {\n      for (let index=0; index < lines.length; index++) {\n        let line = lines[index];\n        // stop if we're not running (user pressed \"stop\" button\n        if (!this.getRunning()) {\n          return false;\n        }\n\n        // ignore comments\n        if (line.startsWith(\"#\")) {\n          continue;\n        }\n\n        // variables\n        line = this._translateVariables(line);\n\n        // play macros recursively\n        let [command, ...args] = this.tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        if (macro_lines !== undefined) {\n          this.__macro_playing = command;\n          if (steps) {\n            step++;\n            this.debug(`\\n===== Step ${step} / ${steps}, executing macro ${command} =====`);\n          }\n          await this._play(macro_lines);\n          this.__macro_playing = null;\n          continue;\n        }\n\n        // count steps if given, wait doesn't count as a step\n        if (steps && !line.startsWith(\"wait\") && !line.startsWith(\"delay\")) {\n          step++;\n          // inform listeners\n          this.fireDataEvent(\"progress\", [step, steps]);\n          this.debug(`\\n===== Step ${step} / ${steps} ====`);\n        }\n        // ignore delay in test mode\n        if (this.getMode() === \"test\" && line.startsWith(\"delay\")) {\n          continue;\n        }\n\n        let result, code;\n\n        try {\n          // translate\n          code = await this._translateLine(line);\n          // skip empty lines\n          if (!code) {\n            continue;\n          }\n\n          // handle multiple lines from imports\n          if (Array.isArray(code)) {\n            this.__import_playing = true;\n            this.debug(`>>>>>>>>> Start import >>>>>>>>>>>>>`);\n            await this._play(code, code.length, 0);\n            this.__import_playing = false;\n            this.debug(`<<<<<<<<< End import ><<<<<<<<<<<<<<`);\n            continue;\n          }\n\n          this.debug(`${line}\\n${\"-\".repeat(40)}\\n${code}`);\n\n          // execute\n          result = window.eval(code);\n        } catch (e) {\n          if (!e.code) {\n            if (this.__macro_playing) {\n              e.macro = this.__macro_playing;\n            }\n            if (this.__import_playing) {\n              e.import = true;\n            }\n            e.code = code;\n            e.scriptcode = line;\n            e.scriptline = index+1;\n          }\n          throw e;\n        }\n\n        if (result instanceof Promise) {\n          try {\n            await result;\n          } catch (e) {\n            e.code = code;\n            e.scriptcode = line;\n            e.scriptline = index+1;\n            throw e;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Replays the given script of intermediate code\n     * @param scriptOrLines {String|Array}\n     *    The script to replay. If String, assume an unhandled script. If Array,\n     *    assume that script has already been handled by {@link #_handleMeta) and\n     *    split into lines.\n     * @return {Promise} Promise which resolves when the script has been replayed, or\n     * rejects with an error\n     * @todo implement pausing\n     */\n    async replay(scriptOrLines) {\n      this.setRunning(true);\n      let lines = Array.isArray(scriptOrLines) ? scriptOrLines : await this._handleMeta(scriptOrLines);\n      let steps = 0;\n      let await_block= false;\n      for (let line of lines) {\n        if (line.startsWith(\"await-\")) {\n          await_block = true;\n          continue;\n        }\n        if (line.startsWith(\"end\")) {\n          await_block = false;\n          continue;\n        }\n        if (!await_block && !line.startsWith(\"wait \") && !line.startsWith(\"#\") && !line.startsWith(\"delay\")) {\n          steps++;\n        }\n      }\n\n      // replay it!\n      try {\n        await this._play(lines, steps, 0);\n      } catch (e) {\n        let msg;\n        // to do: handle errors in macros and imports\n        msg = `Error executing script, line ${e.scriptline}: ${e.message}.\\nCheck console for more information.`;\n        this.error(`Error executing script, line ${e.scriptline}, code:\\n${e.scriptcode}\\nGenerated code:\\n${e.code}`);\n        switch (this.getMode()) {\n          case \"test\":\n            throw e;\n          case \"presentation\":\n            this.error(e);\n            qxl.dialog.Dialog.error(msg);\n        }\n      }\n      this.setRunning(false);\n      qx.event.Timer.once(() => this.cmd_hide_info(), null, 100);\n    },\n\n    /**\n     * Translates the intermediate code into the target language\n     * @param scriptOrLines {String|Array}\n     *    The script to translate.\n     *    If String, assume an unhandled script. If Array. assume that script\n     *    has already been handled by {@link #_handleMeta) and split into lines\n     * @return {string} executable code\n     */\n    async translate(scriptOrLines) {\n      return this._translate(scriptOrLines);\n    },\n\n    /**\n     * Implementation for #translate(). Returns the translated lines.\n     * @param scriptOrLines {String|Array}\n     *    If String, assume an unhandled script. If Array. assume that script\n     *    has already been handled by {@link #_handleMeta) and split into lines\n     * @param includeUtilityFunctions {Boolean}\n     * @return {string}\n     * @private\n     */\n    async _translate(scriptOrLines, includeUtilityFunctions=true) {\n      let lines = Array.isArray(scriptOrLines) ? scriptOrLines : await this._handleMeta(scriptOrLines);\n      let translatedLines = this._defineVariables();\n      for (let line of lines) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        let [command, ...args] = this.tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        let new_lines = [];\n        for (let l of (macro_lines || [line])) {\n          let code = await this._translateLine(l);\n          if (Array.isArray(code)) {\n            new_lines = new_lines.concat(code);\n          } else {\n            new_lines.push(code);\n          }\n        }\n        translatedLines = translatedLines.concat(new_lines.filter(l => Boolean(l)));\n      }\n      let translation = translatedLines.join(\"\\n\");\n      if (includeUtilityFunctions) {\n        return this._generateUtilityFunctionsCode(translation)\n          .concat(translatedLines)\n          .join(\"\\n\");\n      }\n      return translation;\n    },\n\n    /**\n     * Given an async piece of code which checks for a condition or an application state,\n     * return code that checks for this condition, throwing an error if the\n     * condition hasn't been fulfilled within the set timeout.\n     * @param condition {String} The condition expression as a string\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the condition hasn't been met before the timeout.\n     */\n    generateWaitForConditionCode(condition, timeoutmsg) {\n      qx.core.Assert.assertString(condition);\n      timeoutmsg = timeoutmsg || `Timeout waiting for condition '${condition}' to fulfil.\"`;\n      return `(waitForCondition(() => ${condition}, ${this.getInterval()}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any potential event data) if the given object fires\n     * an event with the given type and data (if applicable) and will reject if the timeout is reached before that happens.\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|undefined} The data to expect. Must be serializable to JSON. Exception: if the data is a string that\n     * starts with \"{verbatim}\", the unquoted string is used\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the event hasn't been fired before the timeout.\n     * @return {String}\n     */\n    generateWaitForEventCode(id, type, data, timeoutmsg) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      if (qx.lang.Type.isString(data) && data.startsWith(\"{verbatim}\")) {\n        data = data.substr(10);\n      } else {\n        data = JSON.stringify(data);\n      }\n      if (!timeoutmsg) {\n        timeoutmsg=`Timeout waiting for event '${type}' on '${id}'`;\n      }\n\n      return `(waitForEvent(\"${id}\", \"${type}\",${data}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any\n     * potential event data) if the given object fires an event with the given\n     * type and data (if applicable). After the timeout, it will execute the\n     * given code and restart the timeout.\n     *\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|null} The data to expect. Must be serializable to JSON. In case\n     * of events that do not have data, you MUST explicitly pass 'undefined' as\n     * argument if you use the following arguments\n     * @param code {String} The code to execute after the timeout\n     * @return {String}\n     */\n    generateWaitForEventTimoutFunction(id, type, data, code) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      return `(new Promise(async (resolve, reject) => { \n        while (true){\n          try {\n            await waitForEvent(qx.core.Id.getQxObject(\"${id}\"), \"${type}\", ${data===undefined?\"undefined\":JSON.stringify(data)}, ${this.getTimeout()});\n            return resolve(); \n          } catch (e) {\n            console.debug(e.message);\n            ${code};\n          }\n        }\n      }))`.split(/\\n/).map(l => l.trim()).join(\"\");\n    },\n\n    /**\n     * Adds a line comment to the target script\n     * @param comment {String}\n     * @return {string}\n     */\n    addComment(comment) {\n      return \"// \" + comment;\n    },\n\n    /**\n     * Escapes all characters in a string that are special characters in a regular expression\n     * @param s {String} The string to escape\n     * @return {String}\n     */\n    escapeRegexpChars(s) {\n      return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    },\n\n    /**\n     * Creates a regular expression that matches a json string. In this string, you can use a regular expression\n     * enclosed by \"<!\" and \"!>\" to replace data that cannot be known in advance, such as tokens or session ids.\n     * Example: '{token:\"<![A-Za-z0-9]{32}!>\",user:\"admin\">' will match '{\"token\":\"OnBHqQd59VHZYcphVADPhX74q0Sc6ERR\",\"user\":\"admin\"}'\n     * @param s {string}\n     */\n    createRegexpForJsonComparison(s) {\n      let searchExp = /<![^<][^!]+!>/g;\n      let foundRegExps = s.match(searchExp);\n      if (foundRegExps && foundRegExps.length) {\n        let index=0;\n        // remove escape sequence\n        foundRegExps = foundRegExps.map(m => m.slice(2, -2));\n        // replace placeholders\n        return this.escapeRegexpChars(s).replace(searchExp, () => foundRegExps[index++]);\n      }\n      return this.escapeRegexpChars(s);\n    },\n\n    /**\n     * Adds promise code to a list of promises that need to resolve before the\n     * script proceeds\n     * @param promiseCode\n     */\n    _addPromiseToAwaitStack(promiseCode) {\n      if (!qx.lang.Type.isArray(this.__promises)) {\n        throw new Error(\"Cannot add promise since no await block has been opened.\");\n      }\n      this.__promises.push(promiseCode);\n    },\n\n    /**\n     * Returns the file extension of the downloaded file in the target language\n     * @return {string}\n     */\n    getExportFileExtension() {\n      throw new Error(\"Method getExportFileExtension must be impemented in subclass\");\n    },\n\n    /**\n     * Whether the player is in an await block\n     * @return {Boolean}\n     */\n    isInAwaitBlock() {\n      return qx.lang.Type.isArray(this.__promises);\n    },\n\n    /**\n     * Returns the storage object\n     * @return {qx.bom.storage.Web}\n     * @private\n     */\n    _getStorage() {\n      return qx.bom.storage.Web.getSession();\n    },\n\n    /**\n     * Saves an imported script\n     * @param uri {String}\n     * @param script {String}\n     */\n    _saveImport(uri, script) {\n      this._getStorage().setItem(\"import:\" + uri, script);\n    },\n\n    /**\n     * Retrieves an imported script by its uri, if it exists\n     * @param uri {String}\n     * @return {String}\n     */\n    _getImport(uri) {\n      return this._getStorage().getItem(\"import:\" + uri);\n    },\n\n    /**\n     * Removes all imported scripts\n     */\n    _clearImports() {\n      this._getStorage().forEach(key => {\n        if (key.startsWith(\"import:\")) {\n          this._getStorage().removeItem(key);\n        }\n      });\n    },\n\n    /*\n    ============================================================================\n       COMMANDS\n    ============================================================================\n    */\n\n    /**\n     * Imports a remote file and caches it locally\n     * @param uri {String}\n     * @return {Promise<array>}\n     */\n    async cmd_import(uri) {\n      const [type, id] = uri.split(\":\");\n      if (type !== \"gist\") {\n        throw new Error(\"Currently, only gists can be imported.\");\n      }\n      // use stored script or load from URI\n      let remoteScript = this._getImport(uri);\n      if (!remoteScript) {\n        remoteScript = await this.getRawGist(id);\n        this._saveImport(uri, remoteScript);\n      }\n      return this._translate(remoteScript, false);\n    },\n\n    /**\n     * Clears locally cached imported scripts in order to force-reload them\n     */\n    cmd_clear_imports() {\n      this._clearImports();\n      return \"\";\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri {String}\n     */\n    cmd_assert_uri(uri) {\n      return `qx.core.Assert.assertEquals(window.location.href, \"${uri}\", \"Script is valid on '${uri}' only'\")`;\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri_regexp {String} A string containing a regular expression\n     */\n    cmd_assert_match_uri(uri_regexp) {\n      if (this.getMode()===\"presentation\") {\n        return `if(!window.location.href.match(new RegExp(\"${uri_regexp}\"))){alert(\"The eventrecorder script is meant to be played on a website that matches '${uri_regexp}'.\");window[\"${this._globalRef}\"].stop();}`;\n      }\n      return `qx.core.Assert.assertMatch(window.location.href, \"${uri_regexp}\", \"Current URL does not match '${uri_regexp}'\")`;\n    },\n\n    /**\n     * Sets the player mode\n     * @param mode\n     * @return {string}\n     */\n    cmd_config_set_mode(mode) {\n      return `window[\"${this._globalRef}\"].setMode(\"${mode}\");`;\n    },\n\n    /**\n     * Starts the definition of a macro\n     * @param macro_name {String}\n     * @param macro_description {String|undefined}\n     * @return {null}\n     */\n    cmd_define(macro_name, macro_description) {\n      if (this.macroExists(macro_name)) {\n        throw new Error(`Cannot define macro '${macro_name}' since a macro of that name already exists.`);\n      }\n      this.addMacro(macro_name, macro_description);\n      this.beginMacroDefintion(macro_name);\n      return null;\n    },\n\n    /**\n     * Ends the definition of a macro or a block of awaitable statements\n     * @return {null}\n     */\n    cmd_end() {\n      if (this.__promises) {\n        let line = this.__promises.length ? `(Promise.all([${this.__promises.join(\",\")}]))` : null;\n        this.__promises = null;\n        return line;\n      }\n      if (this.__macro_stack_index < 0) {\n        throw new Error(`Unexpected 'end'.`);\n      }\n      this.leaveMacroDefinition();\n      return null;\n    },\n\n    /**\n     * Starts a block of statements that return promises. The player will wait for\n     * all of the promises to resolve before proceeding.\n     */\n    cmd_await_all() {\n      this.__promises=[];\n      return null;\n    },\n\n    /**\n     * Throws an error\n     * @param msg {String} The error message\n     */\n    cmd_error(msg) {\n      return `throw new Error(\"${msg}\")`;\n    }\n  }\n});\n"
  ]
}