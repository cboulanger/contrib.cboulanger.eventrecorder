# Qooxoodo Event Recorder

![Eventrecorder screenshot](/docs/eventrecorder-screenshot.png)

This library allows a) to record user interaction for replay in tests, or for use in
a presentation/screencast/"take-a-tour" scenario and/or b) to edit the scripts that
are generated by the recorder or write scripts manually. 

The library consists of 

1. a [object id generator](source/class/cboulanger/eventrecorder/ObjectIdGenerator.js) 
which crawls the entire qooxdoo widget hierarchy to assign unique `qxObjectId` values.
This means you don't have to manually assign these ids beforehand. It also
allows you to script applications of which you cannot change the source code. In 
fact, you can script *any* qooxdoo application this way as long as you can compile
its source code. 

2. a [recorder](source/class/cboulanger/eventrecorder/Recorder.js) that registers 
qooxdoo events and saves them together with the object ids and data in a  simple 
human readable and editable intermediate bash-like 
[DSL](https://en.wikipedia.org/wiki/Domain-specific_language) 
(see the [language reference](#script-language-reference).

3. several [players](source/class/cboulanger/eventrecorder/player) which can translate 
this DSL into code that runs in the browser or by a browser automation 
tool (such as Puppeteer, Selenium, TestCaf√©, etc.) on the server, and 

4. an [UI](source/class/cboulanger/eventrecorder/UiController.js) to control 
recording/replaying, editing, and loading/saving the generated scripts.

**Note:** The recorder is recording the qooxdoo reactions to actual cursor movements and 
clicks/taps, _not the native DOM events_ themselves. That means that in many cases,
the recorder does not know whether an event is caused by human interaction with 
the user interface, or by the application code that is triggered by these 
interactions. Also, the recorder will catch a lot of events, many of which are
not relevant for testing your application. 

That is why in most cases, you will have to manually and extensively edit and 
shorten the recorded script. The recorder therefore includes an editor that
offers autocomplete and other amenities to make this as comfortable as possible.

## Demos

- [Simple event recorder demo in "tour" mode](https://cboulanger.github.io/eventrecorder/): Very simple demo that shows how you can 
  use the event recorder to walk the user through your app, using [this gist](https://gist.github.com/cboulanger/64ed4149a27d48de38d9cb176907355e)

- [Simple event recorder demo with object id tooltips](https://cboulanger.github.io/eventrecorder/eventrecorder_tooltips) 
    This demo displays the object ids which are automatically assigned to the widgets by showing a tooltip when hovering
    over them.

- [WidgetBrowser with autogenerated object ids, id tooltips and event recorder, showcasing the use of variables and macros](https://cboulanger.github.io/eventrecorder/widgetbrowser_recorder)
(Also playing a gist).


## Installation

### As a standalone demo

```bash
npm install -g qxcompiler
git clone https://github.com/cboulanger/eventrecorder.git
cd eventrecorder
qx serve
```

### As an addition to an existing project

The event recorder can be added to any application without having to change
anything in the application itself. To do this, configure a few environment
variables and include the required classes in the application directives of
`compile.json` (See [this example](compile.json)). Typically, that would be
`"cboulanger.eventrecorder.UiController"` and
`"cboulanger.eventrecorder.ObjectIdGenerator"`, but it is also possible to use
the ID generator and a player without the GUI, or a player with or without GUI
if you assign the `qxObjectId`s yourself.

If you use the UI Controller, you must include "qookery.ace.*" as a depencency.
A general requirement is to set the environment variables "module.objectId" and
"eventrecorder.enabled" to `true`.

Here's a example of the `applications` section of `Manifest.json`

```json5
{
 "applications": [
    {
      "title": "Foo",
      "name": "foo",
      "theme": "foo.theme.Theme",
      "class": "foo.Application",
      "bootPath": "source/boot",
      "include": [
        "cboulanger.eventrecorder.UiController",
        "cboulanger.eventrecorder.ObjectIdGenerator",
        "cboulanger.eventrecorder.ObjectIdTooltip",
        "qookery.ace.*" // required for the UIController
      ],
      "environment": {
        "module.objectId": true, // required, the event recorder won't work without this setting
        "eventrecorder.enabled": true,
        "eventrecorder.mode": "presentation", // or "test"
        "eventrecorder.autoplay": false 
      }
    },
    ...
}
```

## API Viewer

The API Viewer app is [here](https://cboulanger.github.io/eventrecorder/apiviewer/#cboulanger.eventrecorder).

## ID generation

By including `"cboulanger.eventrecorder.ObjectIdGenerator"` in your compile.json
(see above), IDs are automatically generated for a large number of widgets. 
However, these ID are long and not descriptive of the actual widget. 
If you want to have readable and easily editable replay scripts, you should 
assign a semantically meaningful `qxObjectId` property to each widget that is 
used in the script. 

## Script language reference

The available commands can be gleaned from the methods of the [cboulanger.eventrecorder.IPlayer interface](https://cboulanger.github.io/eventrecorder/apiviewer/index.html#cboulanger.eventrecorder.IPlayer).

The methods that start with `cmd_` provide the implementation of commands: 
`cmd_execute` will generate code for the `execute` command, `cmd_cmd_open_tree_node`
for the `open-tree-node` command. 

Most commands will be autogenerated by the recorder and are therefore probably 
not of interest to the library user. However, you might need to insert `wait` 
commands manually in order to deal with network or rendering latency (see below).

You also need to convert the "set-*" commands into "await-" commands manually 
because (as stated above) the event recorder doesn't always know whether a change 
event is produced by a user action or by code.

### await-* commands and async issues

In many cases, because of network latency and other issues, events can occur in 
a different order than they were fired when the script was recorded. The `await-*`
commands wait for promises to resolve, so when this happens, timeouts are the
result. Thus, when dealing with multiple `await-*` commands that all have to 
resolve before the test/presentation proceeds, you need to wrap them into a 
`await-all` block like so:

```bash
execute toolbar/logout
await-all
    # all events caused by code on user logout, causing server requests
    # that might introduce latency issues
    await-value user-name#label "Guest User"
    await-selection user-list user-list/list-item-guest
    await-selection-from-selectables table-view 0
    await-selection item-view/stack item-view/table
end
```

### Matching runtime values with `await-match-json`

Very often the event data you receive will contain runtime values which you cannot
know in advance such as tokens or session ids.
 
For this situation, the special commands exist, which will check for regular 
expressions enclosed by `<!` and `!>` to replace data like so: 
`{token:"<![A-Za-z0-9]{32}!>"` will match `{"token":"OnBHqQd59VHZYcphVADPhX74q0Sc6ERR"}`.
Currently the commands `await-property-match-json` and `await-event-match-json`
support this.

For example, the `await-property-match-json` command checks the value of an qx object 
property which has an object id. In the following example, we have a jsonrpc
client which has a `response` property that contains the last response:

```
  execute windows/login/buttons/login
  await-all 
    await-match-json application/jsonrpc/access response {"method":"plaintext"}
    await-match-json application/jsonrpc/access response {"message":"Welcome, Administrator!","token":"<![A-Za-z0-9]{32}!>","sessionId":"<![A-Za-z0-9]{26}!>","error":null}
  end
```

In the string that should be matched by the value, you can use a r. Example: 



### Variables and macros

If you manually edit/write scripts, there are two rudimentary scripting features
that might be useful: variables and
macros. They can be seen in the following code:

```bash
info "This demostrates the use of macros.."
wait 2000

# shorten long, autogenerated ID
FORM=Composite/Scroll/TabView/TabPage/Form/FormItems/GroupBox/Composite/Single

define fill-form
	set-value $FORM/TextField $1
	set-value $FORM/PasswordField $2
	set-value $FORM/TextArea $3
end

fill-form "User 1" "Password 1" "Text for User 1"
wait 2000
fill-form "User 2" "Password 2" "This is a different text for User 2"
wait 2000
fill-form "User 3" "Password 3" "Yet another text for User 3"
```

**Variables** roughly work like in Bash (without any of the more advanced features
of variable expansion): they are simply placeholders for text which get replaced
by that text before the script is evaluated. 

**Macros** are enclosed in "define" and "end" and are evaluated during execution.
Inside macros, "$1", "$2" etc. will be replaced with the value of the the nth
argument passed to the name of the macro in the script.

Do not expect any functionality beyond these rather primitive features (such as
control structures etc.). Any more complex requirement should be solved in the 
target script language.

## Player mode

The player instances can be used in two [modes](https://cboulanger.github.io/eventrecorder/apiviewer/index.html#cboulanger.eventrecorder.player.Abstract#mode): 
- "test": The script is executed ignoring user delays; errors will stop 
execution and will be thrown. This is useful for test runners.
- "presentation": The script is executed with user delays; errors will be
logged to the console but will not stop execution. This is the default mode,
which can be used for application demos. 

## Environment variables

See [here](https://cboulanger.github.io/eventrecorder/apiviewer/#cboulanger.eventrecorder).

## Issues

- when opening a window or a tab containing complex content that requires a bit of
time to render, you probably have to manually insert a `wait 1000` command into
the script. This is because the objects might not yet ready when the next command will
be executed. The same is true for content that depends on network traffic. 

