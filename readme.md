# UI Event Recorder
  
This library allows to record user interaction for replay in tests, or for use in
a presentation/screencast/"take-a-tour" scenario. It consists of 

1. a [object id generator](source/class/cboulanger/eventrecorder/ObjectIdGenerator.js) 
which crawls the entire qooxdoo widget hierarchy to assign unique `qxObjectId` values.
2. a [recorder](source/class/cboulanger/eventrecorder/Recorder.js) that registers 
qooxdoo events and saves them together with the object ids and data in a very 
simple human readable and editable intermediate "language" (see below)
3. several [players](source/class/cboulanger/eventrecorder/player) which can translate 
this "language" into code that runs in the browser or by a browser automation 
tool (such as Puppeteer, Selenium, TestCaf√©, etc.) on the server, and 
4. an [UI](source/class/cboulanger/eventrecorder/UiController.js) to control 
recording/replaying and loading/saving the generated scripts.
 
The event recorder can be added to any application without having to change anything
in the application itself, by simply `include`'ing classes in `compile.json/applications`. 
(See [this example](compile.json)). Typically, that would be `"cboulanger.eventrecorder.UiController"`
and `"cboulanger.eventrecorder.ObjectIdGenerator"`, but it is also possible
to use the ID generator and a player without the GUI, or a player with or without
GUI if you assign the `qxObjectId`s yourself. 

## Demos

- [Simple event recorder demo](https://cboulanger.github.io/eventrecorder/): Very simple demo 
- [Widget Browser with event recorder](https://cboulanger.github.io/eventrecorder/widgetbrowser_recorder): 
  This demo shows how the event recorder is added to an existing application without changing its source code. 
- [Widget Browser with event recorder, autoplaying a gist](https://cboulanger.github.io/eventrecorder/widgetbrowser_recorder/?eventrecorder_gist_id=8f5458b5f694c10951b1a7a0c7cf3d5b&eventrecorder_autostart=1):   
  This downloads the script to replay from a gist at GitHub.
- [Widget Browser with object id tooltip](https://cboulanger.github.io/eventrecorder/widgetbrowser_recorder):
  This demo displays the object ids which are automatically assigned to the widgets by showing a tooltip when hovering
  over them.

## Installation

```bash
npm install -g qxcompiler
git clone https://github.com/cboulanger/eventrecorder.git
cd recorder
qx serve
```

## API Viewer

The API Viewer app is [here](https://cboulanger.github.io/eventrecorder/apiviewer).

## ID generation

By including `"cboulanger.eventrecorder.ObjectIdGenerator"` in your compile.json
(see above), IDs are automatically generated for a large number of widgets. 
However, these ID are long and not descriptive of the actual widget. 
If you want to have readable and easily editable replay scripts, you should 
assign a semantically meaningful `qxObjectId` property to each widget that is 
used in the script. 

## Script language reference

The available commands can be gleaned from the methods of the [cboulanger.eventrecorder.IPlayer interface](https://cboulanger.github.io/eventrecorder/apiviewer/index.html#cboulanger.eventrecorder.IPlayer).

The methods that start with `cmd_` provide the implementation of commands: 
`cmd_execute` will generate code for the `execute` command, `cmd_cmd_open_tree_node`
for the `open-tree-node` command. 

Most commands will be autogenerated by the recorder and are therefore probably 
not of interest to the library user. However, you might want to insert `wait` 
commands manually in order to deal with network or rendering latency (see below).

## Player mode

The player instances can be used in two [modes](https://cboulanger.github.io/eventrecorder/apiviewer/index.html#cboulanger.eventrecorder.player.Abstract#mode): 
- "test": The script is executed ignoring user delays; errors will stop 
execution and will be thrown. This is useful for test runners.
- "presentation": The script is executed with user delays; errors will be
logged to the console but will not stop execution. This is the default mode,
which can be used for application demos. 

## Issues

- when opening a window or a tab containing complex content that requires a bit of
time to render, you probably have to manually insert a `wait 1000` command into
the script. This is because the objects might not yet ready when the next command will
be executed. The same is true for content that depends on network traffic. 
